BEGIN; -- submissions references contests which is defined later

CREATE EXTENSION unaccent;

-- user stuff

CREATE TYPE theme_type AS enum (
    'light',
    'dark'
);


CREATE TABLE IF NOT EXISTS users (
	id 					bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at			timestamptz	NOT NULL DEFAULT NOW(),
	name 				text 	  	NOT NULL UNIQUE,
	admin 				boolean 	NOT NULL DEFAULT false,
	proposer 			boolean		NOT NULL DEFAULT false,
	email 				text 	  	NOT NULL UNIQUE,
	password 			text 	  	NOT NULL,
	bio 				text 		NOT NULL DEFAULT '',
    generated           boolean     NOT NULL DEFAULT false,
	
	verified_email 		boolean		NOT NULL DEFAULT false,
	email_verif_sent_at timestamptz,

	preferred_language  text        NOT NULL DEFAULT 'ro',
    preferred_theme     theme_type  NOT NULL DEFAULT 'dark',

    name_change_required boolean NOT NULL DEFAULT false,
    locked_login boolean NOT NULL DEFAULT false
);

CREATE TABLE IF NOT EXISTS username_change_history (
    user_id     bigint      NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    changed_at  timestamptz NOT NULL,
    name    text        NOT NULL
);

-- problem stuff

CREATE TYPE scoring_type AS enum (
    'max_submission',
    'sum_subtasks'
);

CREATE TABLE IF NOT EXISTS problems (
	id 			  	bigint 			    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	  	timestamptz 		NOT NULL DEFAULT NOW(),
	name 		  	text 	    		NOT NULL,
	test_name 	  	text      			NOT NULL,
	time_limit 	  	double precision 	NOT NULL DEFAULT 0.1,
	memory_limit  	integer   			NOT NULL DEFAULT 65536,

	source_size   	integer   			NOT NULL DEFAULT 30000,
	console_input 	boolean 			NOT NULL DEFAULT false,
	visible 	  	boolean 			NOT NULL DEFAULT false,

	source_credits 	text				NOT NULL DEFAULT '',
	default_points 	integer 			NOT NULL DEFAULT 0,
    scoring_strategy scoring_type NOT NULL DEFAULT 'max_submission',

    published_at timestamptz
);

CREATE TABLE IF NOT EXISTS tests (
	id 			bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz		NOT NULL DEFAULT NOW(),
	score 		integer 		NOT NULL,
	problem_id  bigint			NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id  bigint 			NOT NULL,
);


CREATE TABLE IF NOT EXISTS subtasks (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at  timestamptz NOT NULL DEFAULT NOW(),
	problem_id 	bigint 		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id 	integer 	NOT NULL,
	score 		integer 	NOT NULL
);

CREATE TABLE IF NOT EXISTS subtask_tests (
    subtask_id bigint NOT NULL REFERENCES subtasks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    test_id bigint NOT NULL REFERENCES tests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE (subtask_id, test_id)
);

-- blog posts

CREATE TABLE IF NOT EXISTS blog_posts (
	id 				bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at		timestamptz	NOT NULL DEFAULT NOW(),
    author_id       bigint      NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    title           text        NOT NULL,

    slug            text        NOT NULL UNIQUE, 
    visible         boolean     NOT NULL DEFAULT FALSE,

    published_at timestamptz
);

-- contests

CREATE TABLE IF NOT EXISTS contests (
	id 					bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at			timestamptz	NOT NULL DEFAULT NOW(),
	name 				text 	  	NOT NULL UNIQUE,

    public_join         boolean     NOT NULL DEFAULT true,
    start_time          timestamptz NOT NULL,
    end_time            timestamptz NOT NULL,
    max_sub_count       integer     NOT NULL DEFAULT 30,

    virtual             boolean     NOT NULL DEFAULT false,
    visible             boolean     NOT NULL DEFAULT false,

    per_user_time       integer     NOT NULL DEFAULT 0, -- seconds
    register_during_contest boolean NOT NULL DEFAULT false,

    description         text        NOT NULL DEFAULT '',

    public_leaderboard boolean NOT NULL DEFAULT FALSE

    CHECK (start_time <= end_time)
);

CREATE TYPE pbaccess_type AS ENUM (
    'editor',
    'viewer'
); 

CREATE TABLE IF NOT EXISTS contest_user_access (
    contest_id  bigint           NOT NULL REFERENCES contests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id     bigint           NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    access      pbaccess_type    NOT NULL,

    UNIQUE (contest_id, user_id)
);

CREATE TABLE IF NOT EXISTS contest_problems (
    contest_id bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    problem_id bigint NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (contest_id, problem_id)
);

CREATE TABLE IF NOT EXISTS contest_registrations (
	created_at	    timestamptz  NOT NULL DEFAULT NOW(),
    user_id         bigint       NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    contest_id      bigint       NOT NULL REFERENCES contests(id) ON DELETE CASCADE,

    individual_start_at timestamptz,
    individual_end_at timestamptz,

    UNIQUE (user_id, contest_id)
);

CREATE TABLE IF NOT EXISTS contest_questions (
    id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    author_id      bigint NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    contest_id     bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    question       text   NOT NULL,
    created_at 	   timestamptz NOT NULL DEFAULT NOW(),

    responded_at   timestamptz,
    response       text
);

CREATE TABLE IF NOT EXISTS contest_announcements (
    id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    contest_id     bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    announcement   text   NOT NULL,
    created_at 	   timestamptz NOT NULL DEFAULT NOW()
);


-- submissions stuff

CREATE TYPE status AS ENUM (
	'creating',
	'waiting',
	'working',
	'finished'
);

CREATE TABLE IF NOT EXISTS submissions (
	id 				bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 		timestamptz		NOT NULL DEFAULT NOW(),
	user_id 		bigint			NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	problem_id 		bigint  		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    contest_id      bigint          REFERENCES contests(id) ON DELETE SET NULL,
	language		text 			NOT NULL,
	code 			text 			NOT NULL,
	status 			status 			NOT NULL DEFAULT 'creating',
	compile_error 	boolean,
	compile_message text,
	score 			integer			NOT NULL DEFAULT 0,
	max_time 		DOUBLE PRECISION NOT NULL DEFAULT -1,
	max_memory 		INTEGER 		NOT NULL DEFAULT -1,
    code_size       INTEGER         NOT NULL GENERATED ALWAYS AS (length(code)) STORED
);

CREATE TABLE IF NOT EXISTS submission_tests (
	id 				bigint 			    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 		timestamptz			NOT NULL DEFAULT NOW(),
	done			boolean 			NOT NULL DEFAULT false,
	verdict 		text         		NOT NULL DEFAULT '',
	time 			double precision	NOT NULL DEFAULT 0,
	memory 			integer				NOT NULL DEFAULT 0,
	score 			integer				NOT NULL DEFAULT 0,
	test_id			bigint  			REFERENCES tests(id) ON DELETE SET NULL,
	user_id 		bigint  			NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	submission_id 	bigint  			NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
    contest_id      bigint              REFERENCES contests(id) ON DELETE SET NULL,

    -- copied from problem test
    visible_id      bigint              NOT NULL,
    max_score       bigint              NOT NULL
);

CREATE TABLE IF NOT EXISTS submission_subtasks (
    id              bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at      timestamptz     NOT NULL DEFAULT NOW(),
    submission_id   bigint          NOT NULL REFERENCES submissions(id) ON DELETE CASCADE ON UPDATE CASCADE,
    contest_id      bigint          REFERENCES contests(id) ON DELETE SET NULL,

    final_percentage bigint DEFAULT NULL,

    -- user_id might be useful in the future
    -- if I ever implement a cross-submission total score system
    user_id         bigint          NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    
    -- Might be useful to also store subtask id, just in case, even if it may never be properly used
    subtask_id      bigint          REFERENCES subtasks(id) ON DELETE SET NULL ON UPDATE CASCADE,

    -- Copy attributes from subtask
	problem_id 	    bigint 		    NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id 	    integer 	    NOT NULL,
	score 		    integer 	    NOT NULL,
    UNIQUE (submission_id, subtask_id)
);

CREATE TABLE IF NOT EXISTS submission_subtask_subtests (
    submission_subtask_id   bigint NOT NULL REFERENCES submission_subtasks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    submission_test_id      bigint NOT NULL REFERENCES submission_tests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE (submission_subtask_id, submission_test_id)
);

CREATE TABLE IF NOT EXISTS submission_pastes (
    paste_id        text    NOT NULL UNIQUE,
    submission_id   bigint  NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
    author_id       bigint  NOT NULL REFERENCES users(id) ON DELETE CASCADE 
);

CREATE TABLE IF NOT EXISTS problem_lists (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	author_id 	bigint 		NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	title 		text 		NOT NULL DEFAULT '',
    sidebar_hidable boolean NOT NULL DEFAULT false,
	description text 		NOT NULL DEFAULT ''
);

CREATE TABLE IF NOT EXISTS problem_list_problems (
    pblist_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    problem_id bigint NOT NULL REFERENCES problems(id) ON DELETE CASCADE ON UPDATE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (pblist_id, problem_id)
);

CREATE TABLE IF NOT EXISTS problem_list_pblists (
    parent_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    child_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (parent_id, child_id),
	CHECK (parent_id != child_id)
);

CREATE TABLE IF NOT EXISTS sessions (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    expires_at  timestamptz NOT NULL
);

CREATE TABLE IF NOT EXISTS verifications (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS pwd_reset_requests (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS attachments (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	visible 	boolean 	NOT NULL DEFAULT true,
	private 	boolean 	NOT NULL DEFAULT false,
    execable    boolean     NOT NULL DEFAULT false,

	name 		text 		NOT NULL,
	data 		bytea 		NOT NULL,
	data_size 	INTEGER 	GENERATED ALWAYS AS (length(data)) STORED,

    last_updated_at timestamptz NOT NULL DEFAULT NOW(),
    last_updated_by bigint REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS problem_attachments_m2m (
	problem_id 	    bigint 		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	attachment_id 	bigint 		NOT NULL REFERENCES attachments(id) ON DELETE CASCADE,
    UNIQUE (problem_id, attachment_id)
);

CREATE TABLE IF NOT EXISTS blog_post_attachments_m2m (
	blog_post_id    bigint 		NOT NULL REFERENCES blog_posts(id) ON DELETE CASCADE,
	attachment_id 	bigint 		NOT NULL REFERENCES attachments(id) ON DELETE CASCADE,
    UNIQUE (blog_post_id, attachment_id)
);

CREATE TABLE IF NOT EXISTS audit_logs (
    id          bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    logged_at   timestamptz     NOT NULL DEFAULT NOW(),
    system_log  boolean         NOT NULL DEFAULT false,
    msg         text            NOT NULL DEFAULT '',
    author_id   bigint          DEFAULT null REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS problem_user_access (
    problem_id  bigint           NOT NULL REFERENCES problems(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id     bigint           NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    access      pbaccess_type    NOT NULL,

    UNIQUE (problem_id, user_id)
);

-- tags


CREATE TYPE tag_type AS ENUM (
    'author',
    'contest',
    'method',
    'other'
); 


CREATE TABLE IF NOT EXISTS tags (
    id      bigint      GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name    text        NOT NULL UNIQUE,
    type    tag_type    NOT NULL
);

CREATE TABLE IF NOT EXISTS problem_tags (
    tag_id      bigint  NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    problem_id  bigint  NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    position    bigint  NOT NULL DEFAULT 0,
    UNIQUE (tag_id, problem_id)
);

-- views

-- TODO: Remove problem_attachments and blog_post_attachments

CREATE VIEW problem_attachments AS 
    SELECT  atts.id AS id, 
            atts.created_at AS created_at, 
            atts.last_updated_at AS last_updated_at, 
            atts.last_updated_by AS last_updated_by, 
            atts.visible AS visible, 
            atts.private AS private,
            atts.execable AS execable,
            atts.name AS name,
            atts.data AS data,
            atts.data_size AS data_size,
            pam.problem_id AS problem_id 
    FROM attachments atts, problem_attachments_m2m pam 
    WHERE atts.id = pam.attachment_id;

CREATE VIEW blog_post_attachments AS 
    SELECT  atts.id AS id, 
            atts.created_at AS created_at, 
            atts.last_updated_at AS last_updated_at, 
            atts.last_updated_by AS last_updated_by, 
            atts.visible AS visible, 
            atts.private AS private,
            atts.execable AS execable,
            atts.name AS name,
            atts.data AS data,
            atts.data_size AS data_size,
            bpam.blog_post_id AS blog_post_id 
    FROM attachments atts, blog_post_attachments_m2m bpam 
    WHERE atts.id = bpam.attachment_id;

CREATE OR REPLACE VIEW submission_subtask_max_scores (problem_id, user_id, subtask_id, max_score) AS
    SELECT problem_id, user_id, subtask_id, MAX(ROUND(COALESCE(final_percentage, 0) * score / 100.0)) max_score
    FROM submission_subtasks stks
    WHERE subtask_id IS NOT NULL GROUP BY user_id, problem_id, subtask_id;

CREATE OR REPLACE VIEW max_score_view (user_id, problem_id, score) AS 
    WITH max_submission_strat AS (
        SELECT user_id, problem_id, MAX(score) AS max_score FROM submissions GROUP BY user_id, problem_id
    ), sum_subtasks_strat AS (
        SELECT user_id, problem_id, coalesce(SUM(max_score), -1) AS max_score FROM submission_subtask_max_scores GROUP BY user_id, problem_id
    ) SELECT users.id user_id, 
            pbs.id problem_id, 
            CASE WHEN pbs.scoring_strategy = 'max_submission' THEN COALESCE(ms_sub.max_score, -1)
                 WHEN pbs.scoring_strategy = 'sum_subtasks'   THEN COALESCE(ms_subtask.max_score, -1)
                 ELSE -1
            END score
    FROM (problems pbs CROSS JOIN users) 
        LEFT JOIN max_submission_strat ms_sub ON (ms_sub.user_id = users.id AND ms_sub.problem_id = pbs.id)
        LEFT JOIN sum_subtasks_strat ms_subtask ON (ms_subtask.user_id = users.id AND ms_subtask.problem_id = pbs.id);


CREATE OR REPLACE VIEW running_contests AS (
    SELECT * from contests WHERE contests.start_time <= NOW() AND NOW() <= contests.end_time
);

CREATE MATERIALIZED VIEW IF NOT EXISTS problem_statistics (problem_id, num_attempted, num_solved) AS
    SELECT problem_id, COUNT(*) AS num_attempted, COUNT(*) FILTER (WHERE score = 100) AS num_solved FROM max_score_view WHERE score != -1 GROUP BY problem_id;

CREATE OR REPLACE VIEW pblist_user_solved (user_id, list_id, count) AS 
    SELECT msv.user_id, pbs.list_id, COUNT(pbs.list_id) 
    FROM problem_list_deep_problems pbs, max_score_view msv 
    WHERE msv.score = 100 AND msv.problem_id = pbs.problem_id 
    GROUP BY list_id, user_id;

-- param 1: the user ID for which we want to see the visible problems
CREATE OR REPLACE FUNCTION visible_pbs(user_id bigint) RETURNS TABLE (problem_id bigint, user_id bigint) AS $$
    (SELECT pbs.id as problem_id, 0 as user_id
        FROM problems pbs
        WHERE pbs.visible = true AND 0 = $1) -- Base case, problem is visible
    UNION ALL
    (SELECT pbs.id as problem_id, users.id as user_id 
        FROM users CROSS JOIN problems pbs
        WHERE (pbs.visible = true OR users.admin = true) AND users.id = $1) -- Problem is visible or user is admin
    UNION ALL
    (SELECT problem_id, user_id FROM problem_user_access WHERE user_id = $1) -- Problem editors/viewers
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.user_id as user_id 
        FROM contest_problems pbs, contest_user_access users 
        WHERE pbs.contest_id = users.contest_id AND users.user_id = $1) -- Contest testers/viewers
    UNION ALL
    (SELECT pbs.problem_id as problem_id, 0 as user_id
        FROM contest_problems pbs, contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true
        AND contests.end_time <= NOW()
        AND 0 = $1) -- Visible contests after they ended for anons. TODO: Find alternative
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.id as user_id
        FROM contest_problems pbs, users, contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true
        AND contests.end_time <= NOW()
        AND users.id = $1) -- Visible contests after they ended
    UNION ALL
    (SELECT pbs.problem_id as problem_id, 0 as user_id
        FROM contest_problems pbs, running_contests contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true 
        AND contests.per_user_time = 0 AND contests.register_during_contest = false
        AND 0 = $1) -- Visible, running, non-USACO contests with no registering during contest, for anons. TODO: Find alternative
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.id as user_id
        FROM contest_problems pbs, users, running_contests contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true 
        AND contests.per_user_time = 0 AND contests.register_during_contest = false
        AND users.id = $1) -- Visible, running, non-USACO contests with no registering during contest
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.user_id as user_id
        FROM contest_problems pbs, contest_registrations users, running_contests contests 
        WHERE pbs.contest_id = contests.id AND contests.id = users.contest_id 
        AND contests.per_user_time = 0
        AND users.user_id = $1) -- Contest registrants during the contest for non-USACO style
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.user_id as user_id
        FROM contest_problems pbs, contest_registrations users, running_contests contests 
        WHERE pbs.contest_id = contests.id AND contests.id = users.contest_id 
        AND contests.per_user_time > 0 AND users.individual_start_at IS NOT NULL
        AND users.user_id = $1); -- Contest registrants that started during the contest for USACO-style contests
$$ LANGUAGE SQL STABLE;


-- Note: This must be in sync with sudoapi/filters.go:IsBlogPostVisible
CREATE OR REPLACE FUNCTION visible_posts(user_id bigint) RETURNS TABLE (post_id bigint, user_id bigint) AS $$
    SELECT id AS post_id, $1 AS user_id FROM blog_posts 
        WHERE 
            visible = true OR 
            EXISTS (SELECT 1 FROM users WHERE id = $1 AND admin = true) OR 
            author_id = $1
$$ LANGUAGE SQL STABLE;

-- param 1: the user ID for which we want to see the persistently visible problems
-- persistently visible problems are problems that aren't conditioned on contest participation to be visible
CREATE OR REPLACE FUNCTION persistently_visible_pbs(user_id bigint) RETURNS TABLE (problem_id bigint, user_id bigint) AS $$
    (SELECT pbs.id as problem_id, 0 as user_id
        FROM problems pbs
        WHERE pbs.visible = true AND 0 = $1) -- Base case, problem is visible
    UNION ALL
    (SELECT pbs.id as problem_id, users.id as user_id 
        FROM users CROSS JOIN problems pbs
        WHERE (pbs.visible = true OR users.admin = true) AND users.id = $1) -- Problem is visible or user is admin
    UNION ALL
    (SELECT problem_id, user_id FROM problem_user_access WHERE user_id = $1) -- Problem editors/viewers
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.user_id as user_id 
        FROM contest_problems pbs, contest_user_access users 
        WHERE pbs.contest_id = users.contest_id AND users.user_id = $1) -- Contest testers/viewers
    UNION ALL
    (SELECT pbs.problem_id as problem_id, 0 as user_id
        FROM contest_problems pbs, contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true
        AND contests.end_time <= NOW()
        AND 0 = $1) -- Visible contests after they ended for anons. TODO: Find alternative
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.id as user_id
        FROM contest_problems pbs, users, contests
        WHERE pbs.contest_id = contests.id AND contests.visible = true
        AND contests.end_time <= NOW()
        AND users.id = $1); -- Visible contests after they ended
$$ LANGUAGE SQL STABLE;

CREATE OR REPLACE VIEW problem_editors AS
    (SELECT pbs.id as problem_id, users.id as user_id 
        FROM problems pbs, users 
        WHERE users.admin = true) -- User is admin
    UNION ALL
    (SELECT problem_id, user_id FROM problem_user_access WHERE access = 'editor') -- Problem editors
    UNION ALL
    (SELECT pbs.problem_id as problem_id, users.user_id as user_id 
        FROM contest_problems pbs, contest_user_access users 
        WHERE pbs.contest_id = users.contest_id AND users.access = 'editor'); -- Contest editors

-- Cases where a contest should be visible:
--   - It's visible
--   - Admins
--   - Testers/Editors
--   - It's not visible but it's running and user is registered

CREATE OR REPLACE VIEW contest_visibility AS (
    (SELECT contests.id AS contest_id, 0 AS user_id FROM contests 
        WHERE contests.visible = true) -- visible to anonymous users
    UNION
    (SELECT contests.id AS contest_id, users.id AS user_id FROM contests, users 
        WHERE contests.visible = true OR users.admin = true) -- visible to logged in users and admins
    UNION
    (SELECT contest_id, user_id FROM contest_user_access) -- Testers/Editors
    UNION
    (SELECT contests.id AS contest_id, users.user_id AS user_id FROM contests, contest_registrations users 
        WHERE contests.id = users.contest_id AND contests.visible = false) -- not visible but registered
);


CREATE OR REPLACE VIEW contest_submission_subtask_max_scores (problem_id, user_id, subtask_id, contest_id, max_score) AS
    SELECT MAX(stks.problem_id) as problem_id, stks.user_id, subtask_id, subs.contest_id, MAX(ROUND(COALESCE(final_percentage, 0) * stks.score / 100.0)) max_score
    FROM submission_subtasks stks INNER JOIN submissions subs ON stks.submission_id = subs.id
    WHERE subtask_id IS NOT NULL AND subs.contest_id IS NOT NULL GROUP BY stks.user_id, subtask_id, subs.contest_id;

-- TODO: Refactor this like above
CREATE OR REPLACE VIEW max_score_contest_view (user_id, problem_id, contest_id, score) AS 
    WITH max_submission_strat AS (
        SELECT user_id, problem_id, contest_id, MAX(score) AS max_score FROM submissions WHERE contest_id IS NOT NULL GROUP BY user_id, problem_id, contest_id
    ), sum_subtasks_strat AS (
        SELECT user_id, problem_id, contest_id, coalesce(SUM(max_score), -1) AS max_score FROM contest_submission_subtask_max_scores GROUP BY user_id, problem_id, contest_id
    ) SELECT users.user_id user_id, 
            pbs.problem_id problem_id,
            users.contest_id contest_id, 
            CASE WHEN problems.scoring_strategy = 'max_submission' THEN COALESCE(ms_sub.max_score, -1)
                 WHEN problems.scoring_strategy = 'sum_subtasks'   THEN COALESCE(ms_subtask.max_score, -1)
                 ELSE -1
            END score
    FROM ((contest_problems pbs INNER JOIN contest_registrations users ON users.contest_id = pbs.contest_id) INNER JOIN problems ON pbs.problem_id = problems.id) 
        LEFT JOIN max_submission_strat ms_sub ON (ms_sub.user_id = users.user_id AND ms_sub.problem_id = pbs.problem_id AND ms_sub.contest_id = users.contest_id)
        LEFT JOIN sum_subtasks_strat ms_subtask ON (ms_subtask.user_id = users.user_id AND ms_subtask.problem_id = pbs.problem_id AND ms_subtask.contest_id = users.contest_id);

-- Since we now return -1 on no attempt, we must filter it when computing the top view
-- also, exclude contest editors/testers since they didn't get that score legit
CREATE OR REPLACE VIEW contest_top_view
    AS WITH contest_scores AS (
        SELECT user_id, contest_id, SUM(score) AS total_score FROM max_score_contest_view WHERE score >= 0 GROUP BY user_id, contest_id
    ) SELECT users.user_id, users.contest_id, COALESCE(scores.total_score, 0) AS total_score 
    FROM (SELECT regs.* FROM contest_registrations regs LEFT JOIN contest_user_access acc ON regs.user_id = acc.user_id AND regs.contest_id = acc.contest_id WHERE acc.user_id IS NULL) users LEFT OUTER JOIN contest_scores scores ON users.user_id = scores.user_id AND users.contest_id = scores.contest_id ORDER BY contest_id, total_score DESC, user_id;


CREATE OR REPLACE FUNCTION visible_submissions(user_id bigint) RETURNS TABLE (sub_id bigint, user_id bigint) AS $$
    WITH v_pbs AS (SELECT * FROM visible_pbs($1))
    (SELECT id as sub_id, submissions.user_id as user_id 
        FROM submissions, v_pbs
        WHERE submissions.user_id = $1 AND submissions.problem_id = v_pbs.problem_id) -- base case, users should see their own submissions if problem is still visible (also, coincidentally, works for contest problems)
    UNION ALL
    (SELECT subs.id as sub_id, users.id as user_id
        FROM submissions subs, users
        WHERE users.admin = true AND users.id = $1) -- user admins
    UNION ALL
    (SELECT subs.id as sub_id, pb_viewers.user_id as user_id
        FROM submissions subs, v_pbs pb_viewers
        WHERE pb_viewers.problem_id = subs.problem_id AND subs.contest_id IS null) -- contest is null, so judge if problem is visible
    UNION ALL
    (SELECT subs.id as sub_id, users.user_id as user_id
        FROM submissions subs, contest_user_access users
        WHERE users.contest_id = subs.contest_id AND users.user_id = $1) -- contest staff if contest is not null
    UNION ALL
    (SELECT subs.id as sub_id, viz.user_id as user_id
        FROM submissions subs, contests, contest_visibility viz, contest_problems c_pbs
        WHERE contests.id = subs.contest_id AND contests.id = viz.contest_id AND contests.id = c_pbs.contest_id
        AND c_pbs.problem_id = subs.problem_id
        AND contests.end_time <= NOW()
        AND viz.user_id = $1) -- ended contest, so everyone that can see the contest can also see submission
            -- (if they can see the contest, they can also see the problem, since it ended)
$$ LANGUAGE SQL STABLE;

CREATE OR REPLACE VIEW problem_list_deep_problems (list_id, problem_id) AS
    WITH RECURSIVE pblist_tree(list_id, problem_id) AS (
        SELECT pblist_id AS list_id, problem_id FROM problem_list_problems
        UNION
        SELECT pbs.parent_id AS list_id, pt.problem_id FROM problem_list_pblists pbs, pblist_tree PT WHERE pbs.child_id = pt.list_id
    ) SELECT * FROM pblist_tree;

CREATE OR REPLACE VIEW problem_list_pb_count(list_id, count) AS 
    WITH RECURSIVE pblist_tree(list_id, problem_id) AS (
        SELECT pblist_id AS list_id, problem_id FROM problem_list_problems
        UNION
        SELECT pbs.parent_id AS list_id, pt.problem_id FROM problem_list_pblists pbs, pblist_tree PT WHERE pbs.child_id = pt.list_id
    ) SELECT list_id, COUNT(*) FROM pblist_tree GROUP BY list_id;



-- note that, because max_score_view only counts *users* that completed the problem, the num_sols is actually the number of users that completed the problem
-- NOT the number of 100-point solutions (but this metric would be irrelevant in the max-subtasks scoring strategy)
CREATE OR REPLACE VIEW problem_checklist (problem_id, num_pdf, num_md, num_tests, num_subtasks, has_source, num_authors, num_other_tags, num_sols) AS 
    WITH pdf_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM problem_attachments WHERE name LIKE 'statement-%.pdf' GROUP BY problem_id
    ), md_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM problem_attachments WHERE name LIKE 'statement-%.md' GROUP BY problem_id
    ), test_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM tests GROUP BY problem_id
    ), stk_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM subtasks GROUP BY problem_id
    ), author_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM problem_tags 
            WHERE EXISTS (SELECT 1 FROM tags WHERE tags.id = problem_tags.tag_id AND tags.type = 'author') 
        GROUP BY problem_id
    ), tag_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM problem_tags 
            WHERE EXISTS (SELECT 1 FROM tags WHERE tags.id = problem_tags.tag_id AND tags.type != 'author') 
        GROUP BY problem_id
    ), success_cnt AS (
        SELECT problem_id, COUNT(*) AS cnt FROM max_score_view WHERE score = 100 GROUP BY problem_id
    )

    SELECT 
        pbs.id AS problem_id,
        COALESCE(pdf_cnt.cnt, 0) num_pdf,
        COALESCE(md_cnt.cnt, 0) num_md,
        COALESCE(test_cnt.cnt, 0) num_tests,
        COALESCE(stk_cnt.cnt, 0) num_subtasks,
        (length(btrim(pbs.source_credits)) > 0) has_source,
        COALESCE(author_cnt.cnt, 0) num_authors,
        COALESCE(tag_cnt.cnt, 0) num_other_tags,
        COALESCE(success_cnt.cnt, 0) num_sols
    FROM problems pbs 
        LEFT JOIN pdf_cnt ON pbs.id = pdf_cnt.problem_id
        LEFT JOIN md_cnt ON pbs.id = md_cnt.problem_id
        LEFT JOIN test_cnt ON pbs.id = test_cnt.problem_id
        LEFT JOIN stk_cnt ON pbs.id = stk_cnt.problem_id
        LEFT JOIN author_cnt ON pbs.id = author_cnt.problem_id
        LEFT JOIN tag_cnt ON pbs.id = tag_cnt.problem_id
        LEFT JOIN success_cnt ON pbs.id = success_cnt.problem_id;


-- indexes

---- username history

CREATE INDEX username_change_history_uid ON username_change_history(user_id);

---- pblists

CREATE INDEX IF NOT EXISTS pblist_problems_index ON problem_list_problems (pblist_id);
CREATE INDEX IF NOT EXISTS pblist_pblists_index ON problem_list_pblists (parent_id);

---- submissions

CREATE INDEX IF NOT EXISTS problem_user_submissions_index ON submissions (user_id, problem_id);
CREATE INDEX IF NOT EXISTS problem_submissions_index ON submissions (problem_id);
CREATE INDEX IF NOT EXISTS contest_submissions_index ON submissions (contest_id);

CREATE INDEX IF NOT EXISTS submission_subtests_index ON submission_tests (submission_id);
CREATE INDEX IF NOT EXISTS submission_subtests_tests_index ON submission_tests (test_id);
CREATE INDEX IF NOT EXISTS submission_subtasks_index ON submission_subtasks (submission_id);
CREATE INDEX IF NOT EXISTS submission_subtasks_score_index ON submission_subtasks (user_id, problem_id);

---- subtask subtests
CREATE INDEX IF NOT EXISTS stk_stest_m2m_stk_index ON submission_subtask_subtests (submission_subtask_id);
CREATE INDEX IF NOT EXISTS stk_stest_m2m_stest_index ON submission_subtask_subtests (submission_test_id);

---- problems

CREATE INDEX IF NOT EXISTS problem_access_index ON problem_user_access (problem_id);
CREATE INDEX IF NOT EXISTS problem_attachments_index ON attachments (problem_id);
CREATE INDEX IF NOT EXISTS problem_tests_index ON tests (problem_id);
CREATE INDEX IF NOT EXISTS problem_visibility_index ON problems (visible);

---- blogs

CREATE INDEX IF NOT EXISTS blog_post_slug ON blog_posts (slug);
CREATE INDEX IF NOT EXISTS blog_post_author ON blog_posts (author_id);

---- contests

CREATE INDEX IF NOT EXISTS contest_access_index ON contest_user_access (contest_id);
CREATE INDEX IF NOT EXISTS contest_problems_index ON contest_problems (contest_id);
CREATE INDEX IF NOT EXISTS contest_registrations_index ON contest_registrations (contest_id);
CREATE INDEX IF NOT EXISTS contest_questions_index ON contest_questions (contest_id);
CREATE INDEX IF NOT EXISTS contest_announcements_index ON contest_announcements (contest_id);

---- tags

CREATE INDEX IF NOT EXISTS problem_tag_problems ON problem_tags (problem_id);

---- misc

CREATE VIEW active_sessions AS SELECT * FROM sessions WHERE NOW() < expires_at;

-- triggers

CREATE OR REPLACE FUNCTION insert_username_change() RETURNS TRIGGER AS $$
    BEGIN
        IF OLD.name IS DISTINCT FROM NEW.name THEN
            INSERT INTO username_change_history (user_id, changed_at, name) VALUES (NEW.id, NOW(), NEW.name); 
        END IF;
        RETURN NULL;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER username_change_inserts 
    AFTER INSERT OR UPDATE OF name 
    ON users
    FOR EACH ROW
    EXECUTE FUNCTION insert_username_change();

COMMIT;
