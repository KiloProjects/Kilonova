BEGIN; -- submissions references contests which is defined later

CREATE EXTENSION IF NOT EXISTS unaccent;

CREATE TABLE IF NOT EXISTS kn_schema_version (
    version integer not null
);

-- user stuff

CREATE TYPE theme_type AS enum (
    'light',
    'dark'
);


CREATE TABLE IF NOT EXISTS users (
	id 					bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at			timestamptz	NOT NULL DEFAULT NOW(),
	name 				text 	  	NOT NULL UNIQUE,
    display_name        text        NOT NULL DEFAULT '',
	admin 				boolean 	NOT NULL DEFAULT false,
	proposer 			boolean		NOT NULL DEFAULT false,
	email 				text 	  	NOT NULL UNIQUE,
	password 			text 	  	NOT NULL,
	bio 				text 		NOT NULL DEFAULT '',
    generated           boolean     NOT NULL DEFAULT false,
	
	verified_email 		boolean		NOT NULL DEFAULT false,
	email_verif_sent_at timestamptz,

	preferred_language  text        NOT NULL DEFAULT 'ro',
    preferred_theme     theme_type  NOT NULL DEFAULT 'dark',

    name_change_required boolean NOT NULL DEFAULT false,
    locked_login boolean NOT NULL DEFAULT false
);

CREATE TABLE IF NOT EXISTS username_change_history (
    user_id     bigint      NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    changed_at  timestamptz NOT NULL,
    name    text        NOT NULL
);

-- problem stuff

CREATE TYPE scoring_type AS enum (
    'max_submission',
    'sum_subtasks',
    'acm-icpc'
);

CREATE TABLE IF NOT EXISTS problems (
	id 			  	bigint 			    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	  	timestamptz 		NOT NULL DEFAULT NOW(),
	name 		  	text 	    		NOT NULL,
	test_name 	  	text      			NOT NULL,
	time_limit 	  	double precision 	NOT NULL DEFAULT 0.1,
	memory_limit  	integer   			NOT NULL DEFAULT 65536,

	source_size   	integer   			NOT NULL DEFAULT 30000,
	console_input 	boolean 			NOT NULL DEFAULT false,
	visible 	  	boolean 			NOT NULL DEFAULT false,
    digit_precision integer             NOT NULL DEFAULT 0,

	source_credits 	text				NOT NULL DEFAULT '',
	default_points 	numeric 			NOT NULL DEFAULT 0,
    scoring_strategy scoring_type       NOT NULL DEFAULT 'max_submission',
    leaderboard_score_scale numeric     NOT NULL DEFAULT 100,
    
    visible_tests   boolean             NOT NULL DEFAULT false,

    published_at timestamptz
);

CREATE TABLE IF NOT EXISTS tests (
	id 			bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz		NOT NULL DEFAULT NOW(),
	score 		numeric 		NOT NULL,
	problem_id  bigint			NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id  bigint 			NOT NULL
);


CREATE TABLE IF NOT EXISTS subtasks (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at  timestamptz NOT NULL DEFAULT NOW(),
	problem_id 	bigint 		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id 	integer 	NOT NULL,
	score 		numeric 	NOT NULL
);

CREATE TABLE IF NOT EXISTS subtask_tests (
    subtask_id bigint NOT NULL REFERENCES subtasks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    test_id bigint NOT NULL REFERENCES tests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE (subtask_id, test_id)
);

-- blog posts

CREATE TABLE IF NOT EXISTS blog_posts (
	id 				bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at		timestamptz	NOT NULL DEFAULT NOW(),
    author_id       bigint      NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    title           text        NOT NULL,

    slug            text        NOT NULL UNIQUE, 
    visible         boolean     NOT NULL DEFAULT FALSE,

    published_at timestamptz
);

-- contests

CREATE TYPE leaderboard_type AS enum (
    'classic',
    'acm-icpc'
);

CREATE TYPE contest_type AS ENUM (
    'official',
    'virtual'
);

CREATE TABLE IF NOT EXISTS contests (
	id 					bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at			timestamptz	NOT NULL DEFAULT NOW(),
	name 				text 	  	NOT NULL,

    public_join         boolean     NOT NULL DEFAULT true,
    start_time          timestamptz NOT NULL,
    end_time            timestamptz NOT NULL,
    max_sub_count       integer     NOT NULL DEFAULT 30,

    leaderboard_style       leaderboard_type    NOT NULL DEFAULT 'classic',
    leaderboard_freeze_time timestamptz         DEFAULT NULL,
    icpc_submission_penalty integer             NOT NULL DEFAULT 20,
    leaderboard_advanced_filter boolean         NOT NULL DEFAULT FALSE,
    
    type contest_type NOT NULL DEFAULT 'virtual',

    virtual             boolean     NOT NULL DEFAULT false,
    visible             boolean     NOT NULL DEFAULT false,

    per_user_time       integer     NOT NULL DEFAULT 0, -- seconds
    register_during_contest boolean NOT NULL DEFAULT false,

    question_cooldown_ms    integer NOT NULL DEFAULT 2000, -- 2s
    submission_cooldown_ms  integer NOT NULL DEFAULT 10000, -- 10s

    description         text        NOT NULL DEFAULT '',

    public_leaderboard boolean NOT NULL DEFAULT FALSE

    CHECK (start_time <= end_time)
);

CREATE TYPE pbaccess_type AS ENUM (
    'editor',
    'viewer'
); 

CREATE TABLE IF NOT EXISTS contest_user_access (
    contest_id  bigint           NOT NULL REFERENCES contests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id     bigint           NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    access      pbaccess_type    NOT NULL,

    UNIQUE (contest_id, user_id)
);

CREATE TABLE IF NOT EXISTS contest_problems (
    contest_id bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    problem_id bigint NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (contest_id, problem_id)
);

CREATE TABLE IF NOT EXISTS contest_invitations (
    id          text    PRIMARY KEY,
    created_at  timestamptz NOT NULL DEFAULT NOW(),
    contest_id  integer     NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    creator_id  integer     REFERENCES users(id) ON DELETE SET NULL,
    expired     boolean     NOT NULL DEFAULT FALSE,
    max_invitation_cnt integer
);

CREATE TABLE IF NOT EXISTS contest_registrations (
	created_at	    timestamptz  NOT NULL DEFAULT NOW(),
    user_id         bigint       NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    contest_id      bigint       NOT NULL REFERENCES contests(id) ON DELETE CASCADE,

    individual_start_at timestamptz,
    individual_end_at timestamptz,

    invitation_id text REFERENCES contest_invitations(id) ON DELETE SET NULL,

    UNIQUE (user_id, contest_id)
);

CREATE TABLE IF NOT EXISTS contest_questions (
    id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    author_id      bigint NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    contest_id     bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    question       text   NOT NULL,
    created_at 	   timestamptz NOT NULL DEFAULT NOW(),

    responded_at   timestamptz,
    response       text
);

CREATE TABLE IF NOT EXISTS contest_announcements (
    id             bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    contest_id     bigint NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    announcement   text   NOT NULL,
    created_at 	   timestamptz NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS moss_submissions (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at  timestamptz NOT NULL DEFAULT NOW(),
    
    contest_id  bigint      NOT NULL REFERENCES contests(id) ON DELETE CASCADE,
    problem_id  bigint      NOT NULL REFERENCES problems(id) ON DELETE CASCADE,

    language    text NOT NULL,

    url         text        NOT NULL,
    subcount    integer     NOT NULL
);

-- submissions stuff

CREATE TYPE status AS ENUM (
	'creating',
	'waiting',
	'working',
	'finished',
    'reevaling'
);

CREATE TYPE eval_type AS enum (
    'classic',
    'acm-icpc'
);

CREATE TABLE IF NOT EXISTS submissions (
	id 				bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 		timestamptz		NOT NULL DEFAULT NOW(),
	user_id 		bigint			NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	problem_id 		bigint  		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    contest_id      bigint          REFERENCES contests(id) ON DELETE SET NULL,
	language		text 			NOT NULL,
	code 			text 			NOT NULL,
	status 			status 			NOT NULL DEFAULT 'creating',
	
    compile_error 	boolean,
	compile_message text,
    compile_duration DOUBLE PRECISION,

    submission_type eval_type NOT NULL DEFAULT 'classic',
    icpc_verdict    text,
    leaderboard_score_scale numeric NOT NULL DEFAULT 100,

	score 			numeric			NOT NULL DEFAULT 0,
	digit_precision integer         NOT NULL DEFAULT 0,
    
    max_time 		DOUBLE PRECISION NOT NULL DEFAULT -1,
	max_memory 		INTEGER 		NOT NULL DEFAULT -1,
    code_size       INTEGER         NOT NULL GENERATED ALWAYS AS (length(code)) STORED
);

CREATE TABLE IF NOT EXISTS submission_tests (
	id 				bigint 			    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 		timestamptz			NOT NULL DEFAULT NOW(),
	done			boolean 			NOT NULL DEFAULT false,
	verdict 		text         		NOT NULL DEFAULT '',
	time 			double precision	NOT NULL DEFAULT 0,
	memory 			integer				NOT NULL DEFAULT 0,
	percentage		numeric				NOT NULL DEFAULT 0,
	test_id			bigint  			REFERENCES tests(id) ON DELETE SET NULL,
	submission_id 	bigint  			NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
    skipped         boolean             NOT NULL DEFAULT false,

    -- copied from problem test
    visible_id      bigint              NOT NULL,
    score           numeric             NOT NULL
);

CREATE TABLE IF NOT EXISTS submission_subtasks (
    id              bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at      timestamptz     NOT NULL DEFAULT NOW(),
    submission_id   bigint          NOT NULL REFERENCES submissions(id) ON DELETE CASCADE ON UPDATE CASCADE,
    contest_id      bigint          REFERENCES contests(id) ON DELETE SET NULL,

    final_percentage numeric        DEFAULT NULL,
    leaderboard_score_scale numeric NOT NULL DEFAULT 100,

    -- user_id might be useful in the future
    -- if I ever implement a cross-submission total score system
    user_id         bigint          NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    
    -- Might be useful to also store subtask id, just in case, even if it may never be properly used
    subtask_id      bigint          REFERENCES subtasks(id) ON DELETE SET NULL ON UPDATE CASCADE,

    -- Copy attributes from subtask
	problem_id 	    bigint 		    NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	visible_id 	    integer 	    NOT NULL,
	score 		    numeric 	    NOT NULL,
    digit_precision integer         NOT NULL DEFAULT 0,
    computed_score  NUMERIC         NOT NULL GENERATED ALWAYS AS (ROUND(COALESCE(final_percentage, 0) * (score / 100.0), digit_precision)) STORED,

    UNIQUE (submission_id, subtask_id)
);

CREATE TABLE IF NOT EXISTS submission_subtask_subtests (
    submission_subtask_id   bigint NOT NULL REFERENCES submission_subtasks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    submission_test_id      bigint NOT NULL REFERENCES submission_tests(id) ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE (submission_subtask_id, submission_test_id)
);

CREATE TABLE IF NOT EXISTS submission_pastes (
    paste_id        text    NOT NULL UNIQUE,
    submission_id   bigint  NOT NULL REFERENCES submissions(id) ON DELETE CASCADE,
    author_id       bigint  NOT NULL REFERENCES users(id) ON DELETE CASCADE 
);

CREATE TABLE IF NOT EXISTS problem_lists (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	author_id 	bigint 		NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	title 		text 		NOT NULL DEFAULT '',
    sidebar_hidable boolean NOT NULL DEFAULT false,
	description text 		NOT NULL DEFAULT '',

    featured_checklist boolean NOT NULL DEFAULT FALSE
);

CREATE TABLE IF NOT EXISTS problem_list_problems (
    pblist_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    problem_id bigint NOT NULL REFERENCES problems(id) ON DELETE CASCADE ON UPDATE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (pblist_id, problem_id)
);

CREATE TABLE IF NOT EXISTS problem_list_pblists (
    parent_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    child_id bigint NOT NULL REFERENCES problem_lists(id) ON DELETE CASCADE ON UPDATE CASCADE,
    position bigint NOT NULL DEFAULT 0,
    UNIQUE (parent_id, child_id),
	CHECK (parent_id != child_id)
);

CREATE TABLE IF NOT EXISTS sessions (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    expires_at  timestamptz NOT NULL
);

CREATE TABLE IF NOT EXISTS session_clients (
    session_id text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT NOW(),
    last_checked_at timestamptz NOT NULL DEFAULT NOW(),

    ip_addr inet,
    user_agent text,
    user_id bigint,

    CONSTRAINT unique_client_tuple UNIQUE (session_id, ip_addr, user_agent)
);


CREATE TABLE IF NOT EXISTS signup_logs (
    created_at timestamptz NOT NULL DEFAULT NOW(),
    
    user_id bigint NOT NULL,
    ip_addr inet,
    user_agent text
);

CREATE TABLE IF NOT EXISTS verifications (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS pwd_reset_requests (
	id 			text 		PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	user_id 	integer 	NOT NULL REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS attachments (
	id 			bigint 	    GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created_at 	timestamptz NOT NULL DEFAULT NOW(),
	visible 	boolean 	NOT NULL DEFAULT true,
	private 	boolean 	NOT NULL DEFAULT false,
    execable    boolean     NOT NULL DEFAULT false,

	name 		text 		NOT NULL,
	data 		bytea 		NOT NULL,
	data_size 	INTEGER 	GENERATED ALWAYS AS (length(data)) STORED,

    last_updated_at timestamptz NOT NULL DEFAULT NOW(),
    last_updated_by bigint REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS problem_attachments_m2m (
	problem_id 	    bigint 		NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
	attachment_id 	bigint 		NOT NULL REFERENCES attachments(id) ON DELETE CASCADE,
    UNIQUE (problem_id, attachment_id)
);

CREATE TABLE IF NOT EXISTS blog_post_attachments_m2m (
	blog_post_id    bigint 		NOT NULL REFERENCES blog_posts(id) ON DELETE CASCADE,
	attachment_id 	bigint 		NOT NULL REFERENCES attachments(id) ON DELETE CASCADE,
    UNIQUE (blog_post_id, attachment_id)
);

CREATE TABLE IF NOT EXISTS audit_logs (
    id          bigint 			GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    logged_at   timestamptz     NOT NULL DEFAULT NOW(),
    system_log  boolean         NOT NULL DEFAULT false,
    msg         text            NOT NULL DEFAULT '',
    author_id   bigint          DEFAULT null REFERENCES users(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS problem_user_access (
    problem_id  bigint           NOT NULL REFERENCES problems(id) ON DELETE CASCADE ON UPDATE CASCADE,
    user_id     bigint           NOT NULL REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    access      pbaccess_type    NOT NULL,

    UNIQUE (problem_id, user_id)
);

-- tags


CREATE TYPE tag_type AS ENUM (
    'author',
    'contest',
    'method',
    'other'
); 


CREATE TABLE IF NOT EXISTS tags (
    id      bigint      GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name    text        NOT NULL UNIQUE,
    type    tag_type    NOT NULL
);

CREATE TABLE IF NOT EXISTS problem_tags (
    tag_id      bigint  NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    problem_id  bigint  NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    position    bigint  NOT NULL DEFAULT 0,
    UNIQUE (tag_id, problem_id)
);

-- donations

CREATE TYPE donation_source AS enum (
    'buymeacoffee',
    'paypal',
    'other'
);

CREATE TYPE donation_type AS enum (
    'onetime',
    'monthly',
    'yearly'
);

CREATE TABLE IF NOT EXISTS donations (
	id 		   bigint 	        GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    donated_at timestamptz      NOT NULL,
    user_id    bigint           REFERENCES users(id),
    real_name  text             NOT NULL DEFAULT '',
    amount     real             NOT NULL DEFAULT 0,
    currency   text             NOT NULL DEFAULT 'EUR',

    source     donation_source  NOT NULL DEFAULT 'other',
    type       donation_type    NOT NULL DEFAULT 'onetime',

    transaction_id  text         NOT NULL,
    cancelled_at    timestamptz
);

-- views

---- moved to 999.views.sql

-- indexes

---- users and username history

CREATE INDEX IF NOT EXISTS user_admins ON users (admin) WHERE admin = true;
CREATE INDEX IF NOT EXISTS username_change_history_uid ON username_change_history(user_id);

---- pblists

CREATE INDEX IF NOT EXISTS pblist_problems_index ON problem_list_problems (pblist_id);
CREATE INDEX IF NOT EXISTS pblist_pblists_index ON problem_list_pblists (parent_id);

---- submissions

CREATE INDEX IF NOT EXISTS contest_problem_submissions_index ON submissions (contest_id, problem_id);
CREATE INDEX IF NOT EXISTS problem_user_submissions_index ON submissions (user_id, problem_id);
CREATE INDEX IF NOT EXISTS problem_submissions_index ON submissions (problem_id);
CREATE INDEX IF NOT EXISTS contest_submissions_index ON submissions (contest_id);
CREATE INDEX IF NOT EXISTS null_contest_submissions_index ON submissions (contest_id) WHERE contest_id IS NULL;
CREATE INDEX IF NOT EXISTS submission_created_at_index ON submissions (created_at, user_id);

CREATE INDEX IF NOT EXISTS submission_subtests_index ON submission_tests (submission_id);
CREATE INDEX IF NOT EXISTS submission_subtests_tests_index ON submission_tests (test_id);
CREATE INDEX IF NOT EXISTS submission_subtasks_index ON submission_subtasks (submission_id);
CREATE INDEX IF NOT EXISTS submission_subtasks_score_index ON submission_subtasks (user_id, problem_id);
CREATE INDEX IF NOT EXISTS submission_subtasks_problem_index ON submission_subtasks (problem_id);

---- subtask subtests
CREATE INDEX IF NOT EXISTS stk_stest_m2m_stk_index ON submission_subtask_subtests (submission_subtask_id);
CREATE INDEX IF NOT EXISTS stk_stest_m2m_stest_index ON submission_subtask_subtests (submission_test_id);

---- problems

CREATE INDEX IF NOT EXISTS problem_access_index ON problem_user_access (problem_id);
CREATE INDEX IF NOT EXISTS problem_tests_index ON tests (problem_id);
CREATE INDEX IF NOT EXISTS problem_visibility_index ON problems (visible);

---- blogs

CREATE INDEX IF NOT EXISTS blog_post_slug ON blog_posts (slug);
CREATE INDEX IF NOT EXISTS blog_post_author ON blog_posts (author_id);

---- contests

CREATE INDEX IF NOT EXISTS contest_access_index ON contest_user_access (contest_id);
CREATE INDEX IF NOT EXISTS contest_problems_index ON contest_problems (contest_id);
CREATE INDEX IF NOT EXISTS contest_problems_pbid_index ON contest_problems (problem_id);
CREATE INDEX IF NOT EXISTS contest_registrations_index ON contest_registrations (contest_id);
CREATE INDEX IF NOT EXISTS contest_questions_index ON contest_questions (contest_id);
CREATE INDEX IF NOT EXISTS contest_announcements_index ON contest_announcements (contest_id);

-- session clients
CREATE INDEX IF NOT EXISTS session_clients_last_checked_user_id ON session_clients (user_id, last_checked_at);

---- tags

CREATE INDEX IF NOT EXISTS problem_tag_problems ON problem_tags (problem_id);

---- misc

CREATE VIEW active_sessions AS SELECT * FROM sessions WHERE NOW() < expires_at;

-- triggers and functions

CREATE OR REPLACE FUNCTION refresh_hot_pbs(banned_problems bigint[]) RETURNS void AS $$
BEGIN
    DROP MATERIALIZED VIEW IF EXISTS hot_problems;
    EXECUTE format('CREATE MATERIALIZED VIEW hot_problems (problem_id, hot_cnt) AS 
		SELECT problem_id, COUNT(DISTINCT user_id) AS user_cnt FROM submissions
			WHERE created_at >= NOW() - ''7 days''::interval 
				AND problem_id != ANY(%L::bigint[])
			GROUP BY problem_id
		ORDER BY user_cnt DESC;', $1);
    CREATE INDEX ON hot_problems (problem_id);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION insert_username_change() RETURNS TRIGGER AS $$
    BEGIN
        IF OLD.name IS DISTINCT FROM NEW.name THEN
            INSERT INTO username_change_history (user_id, changed_at, name) VALUES (NEW.id, NOW(), NEW.name); 
        END IF;
        RETURN NULL;
    END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER username_change_inserts 
    AFTER INSERT OR UPDATE OF name 
    ON users
    FOR EACH ROW
    EXECUTE FUNCTION insert_username_change();

-- max score logic


CREATE OR REPLACE FUNCTION max_score(user_id bigint, problem_id bigint, OUT mscore decimal) AS $$
DECLARE
    scoring_strat text;
BEGIN
    SELECT scoring_strategy INTO scoring_strat FROM problems WHERE id = $2 LIMIT 1;
    IF scoring_strat = 'max_submission' OR scoring_strat = 'acm-icpc' THEN
        SELECT COALESCE(MAX(score), -1) INTO mscore FROM submissions subs 
            WHERE subs.user_id = $1 AND subs.problem_id = $2;
    ELSE
        WITH subtask_max_scores AS (
            SELECT subtask_id, MAX(computed_score) AS best_score FROM submission_subtasks stks
                WHERE subtask_id IS NOT NULL 
                AND stks.user_id = $1 AND stks.problem_id = $2 
                GROUP BY subtask_id
        ) SELECT COALESCE(SUM(best_score), -1) INTO mscore FROM subtask_max_scores;
    END IF;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE;


CREATE TABLE IF NOT EXISTS max_scores (
    user_id bigint NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    problem_id bigint NOT NULL REFERENCES problems(id) ON DELETE CASCADE,
    score decimal,

    CONSTRAINT unique_max_score_pair UNIQUE (user_id, problem_id)
);

CREATE INDEX IF NOT EXISTS user_max_scores ON max_scores(user_id);
-- used for problem statistics
CREATE INDEX IF NOT EXISTS problem_max_scores ON max_scores(problem_id);

CREATE OR REPLACE FUNCTION reset_max_score(user_id bigint, problem_id bigint) RETURNS void AS $$
    INSERT INTO max_scores (user_id, problem_id, score) 
        SELECT $1 AS user_id, $2 AS problem_id, max_score($1, $2) AS score 
            WHERE EXISTS (SELECT 1 FROM users WHERE id = $1) AND EXISTS (SELECT 1 FROM problems WHERE id = $2) 
        ON CONFLICT ON CONSTRAINT unique_max_score_pair 
            DO UPDATE SET score = max_score($1, $2);
$$ LANGUAGE SQL;

CREATE OR REPLACE FUNCTION score_update_handler() RETURNS TRIGGER AS $$
BEGIN
    RETURN(SELECT reset_max_score(NEW.user_id, NEW.problem_id));
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION score_delete_handler() RETURNS TRIGGER AS $$
BEGIN
    RETURN(SELECT reset_max_score(OLD.user_id, OLD.problem_id));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER submission_score_update
    AFTER INSERT OR UPDATE OF score
    ON submissions
    FOR EACH ROW
    EXECUTE FUNCTION score_update_handler();

CREATE OR REPLACE TRIGGER submission_score_delete
    AFTER DELETE
    ON submissions
    FOR EACH ROW
    EXECUTE FUNCTION score_delete_handler();

COMMIT;