// Code generated by sqlc. DO NOT EDIT.
// source: user.sql

package rawdb

import (
	"context"
	"time"
)

const admins = `-- name: Admins :many
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users
WHERE admin = true
ORDER BY id
`

func (q *Queries) Admins(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, admins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Admin,
			&i.Proposer,
			&i.Email,
			&i.Password,
			&i.Bio,
			&i.DefaultVisible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users 
WHERE lower(name) = lower($1) OR lower(email) = lower($2)
`

type CountUsersParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers, arg.Username, arg.Email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
	email, name, password
) VALUES (
	$1, $2, $3
) 
RETURNING id, created_at, name, admin, proposer, email, password, bio, default_visible
`

type CreateUserParams struct {
	Email    string `json:"email"`
	Name     string `json:"name"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Name, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Admin,
		&i.Proposer,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.DefaultVisible,
	)
	return i, err
}

const proposers = `-- name: Proposers :many
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users 
WHERE proposer = true OR admin = true
ORDER BY id
`

func (q *Queries) Proposers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, proposers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Admin,
			&i.Proposer,
			&i.Email,
			&i.Password,
			&i.Bio,
			&i.DefaultVisible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAdmin = `-- name: SetAdmin :exec
UPDATE users SET admin = $2
WHERE id = $1
`

type SetAdminParams struct {
	ID    int64 `json:"id"`
	Admin bool  `json:"admin"`
}

func (q *Queries) SetAdmin(ctx context.Context, arg SetAdminParams) error {
	_, err := q.db.ExecContext(ctx, setAdmin, arg.ID, arg.Admin)
	return err
}

const setBio = `-- name: SetBio :exec
UPDATE users SET bio = $2
WHERE id = $1
`

type SetBioParams struct {
	ID  int64  `json:"id"`
	Bio string `json:"bio"`
}

func (q *Queries) SetBio(ctx context.Context, arg SetBioParams) error {
	_, err := q.db.ExecContext(ctx, setBio, arg.ID, arg.Bio)
	return err
}

const setDefaultVisibility = `-- name: SetDefaultVisibility :exec
UPDATE users SET default_visible = $2
WHERE id = $1
`

type SetDefaultVisibilityParams struct {
	ID             int64 `json:"id"`
	DefaultVisible bool  `json:"default_visible"`
}

func (q *Queries) SetDefaultVisibility(ctx context.Context, arg SetDefaultVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultVisibility, arg.ID, arg.DefaultVisible)
	return err
}

const setEmail = `-- name: SetEmail :exec
UPDATE users SET email = $2
WHERE id = $1
`

type SetEmailParams struct {
	ID    int64  `json:"id"`
	Email string `json:"email"`
}

func (q *Queries) SetEmail(ctx context.Context, arg SetEmailParams) error {
	_, err := q.db.ExecContext(ctx, setEmail, arg.ID, arg.Email)
	return err
}

const setPassword = `-- name: SetPassword :exec
UPDATE users SET password = $2
WHERE id = $1
`

type SetPasswordParams struct {
	ID       int64  `json:"id"`
	Password string `json:"password"`
}

func (q *Queries) SetPassword(ctx context.Context, arg SetPasswordParams) error {
	_, err := q.db.ExecContext(ctx, setPassword, arg.ID, arg.Password)
	return err
}

const setProposer = `-- name: SetProposer :exec
UPDATE users SET proposer = $2
WHERE id = $1
`

type SetProposerParams struct {
	ID       int64 `json:"id"`
	Proposer bool  `json:"proposer"`
}

func (q *Queries) SetProposer(ctx context.Context, arg SetProposerParams) error {
	_, err := q.db.ExecContext(ctx, setProposer, arg.ID, arg.Proposer)
	return err
}

const solvedProblems = `-- name: SolvedProblems :many
SELECT problem_id FROM submissions
WHERE score = 100 AND user_id = $1
GROUP BY problem_id
ORDER BY problem_id
`

func (q *Queries) SolvedProblems(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, solvedProblems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var problem_id int64
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const top100 = `-- name: Top100 :many
SELECT us.id, us.created_at, us.name, us.admin, us.proposer, us.email, us.password, us.bio, us.default_visible, COUNT(sub.user_id) AS number_problems
FROM users us
LEFT JOIN (
	SELECT problem_id, user_id
	FROM submissions 
	WHERE score = 100 
	GROUP BY problem_id, user_id
) sub
ON   sub.user_id = us.id
GROUP BY us.id 
ORDER BY COUNT(sub.user_id) desc, us.id 
LIMIT 100
`

type Top100Row struct {
	ID             int64     `json:"id"`
	CreatedAt      time.Time `json:"created_at"`
	Name           string    `json:"name"`
	Admin          bool      `json:"admin"`
	Proposer       bool      `json:"proposer"`
	Email          string    `json:"email"`
	Password       string    `json:"password"`
	Bio            string    `json:"bio"`
	DefaultVisible bool      `json:"default_visible"`
	NumberProblems int64     `json:"number_problems"`
}

// I am extremely proud of this
func (q *Queries) Top100(ctx context.Context) ([]Top100Row, error) {
	rows, err := q.db.QueryContext(ctx, top100)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Top100Row
	for rows.Next() {
		var i Top100Row
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Admin,
			&i.Proposer,
			&i.Email,
			&i.Password,
			&i.Bio,
			&i.DefaultVisible,
			&i.NumberProblems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user = `-- name: User :one
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users 
WHERE id = $1
`

func (q *Queries) User(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, user, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Admin,
		&i.Proposer,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.DefaultVisible,
	)
	return i, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users 
WHERE lower(email) = lower($1)
`

func (q *Queries) UserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Admin,
		&i.Proposer,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.DefaultVisible,
	)
	return i, err
}

const userByName = `-- name: UserByName :one
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users 
WHERE lower(name) = lower($1)
`

func (q *Queries) UserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, userByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.Admin,
		&i.Proposer,
		&i.Email,
		&i.Password,
		&i.Bio,
		&i.DefaultVisible,
	)
	return i, err
}

const users = `-- name: Users :many
SELECT id, created_at, name, admin, proposer, email, password, bio, default_visible FROM users
ORDER BY id
`

func (q *Queries) Users(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.Admin,
			&i.Proposer,
			&i.Email,
			&i.Password,
			&i.Bio,
			&i.DefaultVisible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
